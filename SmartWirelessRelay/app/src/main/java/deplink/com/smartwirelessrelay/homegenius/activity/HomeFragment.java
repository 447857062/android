package deplink.com.smartwirelessrelay.homegenius.activity;import android.app.AlertDialog;import android.app.Fragment;import android.content.Intent;import android.os.Bundle;import android.os.Handler;import android.os.Message;import android.util.Log;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.Button;import android.widget.TextView;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.Socket;import javax.net.ssl.SSLSocket;import deplink.com.smartwirelessrelay.homegenius.Devices.EllESDK;import deplink.com.smartwirelessrelay.homegenius.EllESDK.R;import deplink.com.smartwirelessrelay.homegenius.Protocol.GeneralPacket;import deplink.com.smartwirelessrelay.homegenius.util.DataExchange;import deplink.com.smartwirelessrelay.homegenius.util.PublicMethod;import deplink.com.smartwirelessrelay.homegenius.util.SharedPreference;/** * Created by BenondLuo on 2016/7/22. */public class HomeFragment extends Fragment implements View.OnClickListener {    private static final String TAG = "HomeFragment";    private TextView textview_ssid_name;    private TextView textview_uid_name;    private Button button_connect;    private Button button_query_devlist;    private Button button_heath_switch;    private Button button_query_lock_history;    private SSLSocket Client_sslSocket = null;    private GeneralPacket packet;    @Override    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {        View view = inflater.inflate(R.layout.fragment_main_home, container, false);        initFindViewById(view);        return view;    }    @Override    public void onResume() {        super.onResume();        textview_uid_name.setText("uid:" + "还没有获取到");        packet = new GeneralPacket(getActivity());        textview_ssid_name.setText("当前连接的wifi是：" + PublicMethod.getSSID(getActivity()));        //ip地址需要使用手机连接中继然后获取手机的IP地址        //获取路由器分配给本机的IP地址 publicmothed getIPAddress    /* socketClient = new SocketClient("192.168.68.205", 9999);        socketClient.registerSocketDelegate(new SocketClient.SocketDelegate() {            @Override            public void onConnected(SocketClient client) {                GeneralPacket packet = new GeneralPacket(getActivity());                packet.packWirelessPacket();                socketClient.send(packet.data);                textview_show_result.setText("开始验证合法性");                socketClient.setHeartBeatMessage("hello, server !--------------------------->Android");                Log.i("servcer","开始验证合法性 packet.data="+ DataExchange.byteArrayToHexString(packet.data)+" 长度="+ packet.data.length);                SharedPreference sharedPreference = new SharedPreference(getActivity(), "uid");                sharedPreference.saveString("uid","");            }            @Override            public void onDisconnected(SocketClient client) {                Log.i("Server", "timeout socket长连接断开");                textview_show_result.setText(" tcp/ip已断开连接");            }            @Override            public void onResponse(SocketClient client, @NonNull SocketResponsePacket responsePacket) {                Log.i("Server ","响应socket数据"+responsePacket.getData()+"message="+responsePacket.getMessage());                textview_show_result.setText(" 验证通过，已获取uid");                SharedPreference sharedPreference = new SharedPreference(getActivity(), "uid");                sharedPreference.saveString("uid",responsePacket.getMessage());                Log.i("Server uid=", responsePacket.getMessage());            }        });        socketClient.setConnectionTimeout(1000 * 15);        socketClient.setHeartBeatInterval(1000);        socketClient.setRemoteNoReplyAliveTimeout(1000 * 60);        socketClient.setCharsetName("UTF-8");        socketClient.connect();*/    }    protected void initFindViewById(View view) {        textview_ssid_name = (TextView) view.findViewById(R.id.textview_ssid_name);        textview_uid_name = (TextView) view.findViewById(R.id.textview_uid_name);        button_connect = (Button) view.findViewById(R.id.button_connect);        button_heath_switch = (Button) view.findViewById(R.id.button_heath_switch);        button_heath_switch.setOnClickListener(this);        button_connect.setOnClickListener(this);        button_query_devlist = (Button) view.findViewById(R.id.button_query_devlist);        button_query_devlist.setOnClickListener(this);        button_query_lock_history = (Button) view.findViewById(R.id.button_query_lock_history);        button_query_lock_history.setOnClickListener(this);    }    // 不使用证书, 通过ssl socket连接服务器    // 抛出异常, 提示找不到证书    public void sslSocket() {        //  SSLSocketFactory factory = (SSLSocketFactory) SSLSocketFactory        //         .getDefault();        Log.e("kelijun", "sslsocket");        Socket s = null;        try {            s = new Socket("192.168.68.205", 9999);            System.out.println("ok");            Log.e("kelijun", "ok");            OutputStream output = s.getOutputStream();            InputStream input = s.getInputStream();            GeneralPacket packet = new GeneralPacket(getActivity());            packet.packWirelessPacket();            output.write(packet.data);            System.out.println("sent: alert");            Log.e("kelijun", "sent: alert");            output.flush();            byte[] buf = new byte[1024];            int len = input.read(buf);            Log.e("kelijun", "received:" + new String(buf, 0, len));            Log.e("kelijun", "received:" + DataExchange.byteArrayToHexString(buf) + buf.length);        } catch (IOException e) {            Log.e("kelijun", e.getMessage());            e.printStackTrace();        }    }  /*  public void sslSocket2() {        if (null != Client_sslSocket) {            Log.d("init_sslSocket", "ssl socket already exists");            return;        }        try {            // Loading CAs from an InputStream            CertificateFactory cf = null;            cf = CertificateFactory.getInstance("X.509");            final X509Certificate server_ca;            InputStream cert = this.getResources().openRawResource(R.raw.server);            server_ca = (X509Certificate) cf.generateCertificate(cert);            cert.close();            // Creating a KeyStore containing our trusted CAs            String keyStoreType = KeyStore.getDefaultType();            KeyStore keyStore = KeyStore.getInstance(keyStoreType);            keyStore.load(null, null);            keyStore.setCertificateEntry("ca-certificate", server_ca);            InputStream pkcs12in = this.getResources().openRawResource(R.raw.client);            KeyStore pKeyStore = KeyStore.getInstance("PKCS12");            pKeyStore.load(pkcs12in, AppConstant.PASSWORD_FOR_PKCS12.toCharArray());            // Creating a TrustManager that trusts the CAs in our KeyStore.            String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();            TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);            tmf.init(keyStore);            KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());            kmf.init(pKeyStore, null);            pkcs12in.close();            // Creating an SSLSocketFactory that uses our TrustManager            SSLContext sslContext = SSLContext.getInstance("TLS");            sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);            Client_sslSocket = (SSLSocket) sslContext.getSocketFactory().createSocket(AppConstant.SERVER_IP, AppConstant.TCP_CONNECT_PORT);            Log.e("init_sslSocket", "init_sslSocket ");        } catch (Exception e) {            Log.e("init_sslSocket", e.getMessage());            Message msg=Message.obtain();            msg.obj="无法连接服务器";            mHandler.sendMessage(msg);            e.printStackTrace();        }    }*/    public void getOut(SSLSocket socket, byte[] message) {        OutputStream out;        Log.i(TAG, "message=" + DataExchange.byteArrayToHexString(message));        try {            out = socket.getOutputStream();            System.out.println(Client_sslSocket.isBound()); // 是否邦定            System.out.println(Client_sslSocket.isClosed()); // 是否关闭            System.out.println(Client_sslSocket.isConnected()); // 是否连接            System.out.println(Client_sslSocket.isInputShutdown()); // 是否关闭输入流            System.out.println(Client_sslSocket.isOutputShutdown()); // 是否关闭输出流            out.write(message);            Log.e("kelijun", "getOut sent: alert");            out.flush();            // out.println(Arrays.toString(message));            // out.flush();        } catch (IOException e) {            Log.i(TAG, "getOut e");            e.printStackTrace();            // sslSocket2();        }    }    private boolean close = false; // 关闭连接标志位，true表示关闭，false表示开启    @Override    public void onClick(View v) {        switch (v.getId()) {            case R.id.button_connect:                new Thread(new Runnable() {                    @Override                    public void run() {                        //  sslSocket();                        //sslSocket2();                        //---------读数据---------------------------                        if (Client_sslSocket != null) {                        } else {                            EllESDK.getInstance().InitEllESDK(getActivity(), null);                            Client_sslSocket = EllESDK.getInstance().getClient_sslSocket();                        }                        Log.i(TAG, " onClick getIn(Client_sslSocket)" + (Client_sslSocket != null));                        GeneralPacket packet = new GeneralPacket(getActivity());                        packet.packBindPacket();                        EllESDK.getInstance().getOut(packet.data);                        // getOut(Client_sslSocket, packet.data);                        getIn(Client_sslSocket);                        //   }                        //不加密                        // sslSocket();                    }                }).start();                break;            case R.id.button_query_devlist:                startActivity(new Intent(getActivity(), DevListActivity.class));                break;            case R.id.button_query_lock_history:                startActivity(new Intent(getActivity(), LockHistory.class));                break;            case R.id.button_heath_switch:                SharedPreference sharedPreference = new SharedPreference(getActivity(), "heathswitch");                String open = sharedPreference.getString("sharedPreference");                if (open != null && open.equals("open")) {                    sharedPreference.saveString("heathswitch", "close");                    button_heath_switch.setText("关闭");                } else {                    sharedPreference.saveString("heathswitch", "open");                    button_heath_switch.setText("开");                }                break;        }    }    /**     * 判断是否断开连接，断开返回true,没有返回false     *     * @param socket     * @return     */    public Boolean isServerClose(Socket socket) {        try {            socket.sendUrgentData(0);//发送1个字节的紧急数据，默认情况下，服务器端没有开启紧急数据处理，不影响正常通信            return false;        } catch (Exception se) {            return true;        }    }    public void getIn(SSLSocket socket) {        String str;        if (null != Client_sslSocket) {            try {                InputStream input = socket.getInputStream();                byte[] buf = new byte[1024];                int len = input.read(buf);                if (len != -1) {                    str = new String(buf, 0, len);                    System.out.println("received:" + str + "length=" + len);                    System.out.println("received:" + DataExchange.byteArrayToHexString(buf));                    byte[] uid = new byte[32];                    System.arraycopy(buf, 7, uid, 0, 32);                    str = new String(uid);                    Message msg = Message.obtain();                    msg.obj = str;                    mHandler.sendMessage(msg);                }            } catch (IOException e) {                e.printStackTrace();            }        }    }    private Handler mHandler = new Handler() {        @Override        public void handleMessage(Message msg) {            super.handleMessage(msg);            String str = (String) msg.obj;            if (!"无法连接服务器".equals(str)) {                textview_uid_name.setText("uid:" + str);                SharedPreference sharedPreference = new SharedPreference(getActivity(), "uid");                sharedPreference.saveString("uid", str);                Log.i(TAG, "uid=" + str);            }            new AlertDialog                    .Builder(getActivity())                    .setTitle("设备UID")                    .setNegativeButton("确定", null)                    .setIcon(android.R.drawable.ic_menu_agenda)                    .setMessage(str)                    .show();        }    };}